---
layout: post
title: How to grow a system as opposed to building a system
categories: []
status: pending
type: post
published: false
meta:
  _edit_last: '4'
---
<p><em><span style="text-decoration: underline;"><br />
</span></em> <img style="margin: 2px 0px 0px 10px; float: right;" src="http://blogs.headspring.com/content/binary/grow.jpg" alt="grow a system as opposed to building a system" border="0" /> With<br />
regards to growing a system instead of building it, there are lots of lessons that<br />
have been learned throughout the decades in software development, and we at Headspring<br />
prefer not to make the mistakes of previous generations of software development teams<br />
and software development vendors. This means learning from those mistakes and researching,<br />
what in computer science terms are, the ancient scriptures of software which are now<br />
three decades old. That is pretty ancient in software development terms.</p>
<p>Growing a system is what is natural. That is organic software development, to grow<br />
a system over time and consistently test it, consistently use it, and consistently<br />
refine it.</p>
<p><img style="margin: 2px 10px 0px 0px; float: left;" src="http://blogs.headspring.com/content/binary/growing.gif" alt="slowly morph it" border="0" /></p>
<p>It is much like making a clay pot where one starts with a piece of clay. As you start<br />
spinning the wheel, you slowly morph it. You slowly ease it into the shape of a pot<br />
as opposed to building a mold and then injecting clay into the mold or molten aluminum<br />
or something like that.</p>
<p>In the absence of grown development, you don't get feedback until late in the game<br />
when you try to implement. As good as your testing is, until you put the actual users<br />
and the actual data in the actual environment, you don't have proof that the system<br />
solves a business problem. You only have a "good idea" prior to implementation, and,<br />
as some people's good ideas are better than others, you don't have any evidence that<br />
the system actually solves the problem it should.</p>
<p>And so, the sooner you could put your idea into production, the sooner you could have<br />
real feedback feature by feature. Many are skeptical about how soon something can<br />
actually be put into production. You can go in production with just two small features<br />
and only one type of user.</p>
<p>Users can begin using the system with one initial role. Perhaps you will ultimately<br />
have 26 different user groups, different types of security roles, or different types<br />
of people that are going to use the system. But, if you can get the system up and<br />
running for just one of those groups of users you've delivered some value and proved<br />
out that their day to day jobs can be affected and improved by the computer system.<br />
Then you may grow the system user group by user group instead of waiting a significant<br />
period of time before actually implanting the software in a production environment.<br />
This of course will help you evaluate the capability of the vendor you hire before<br />
you spend anywhere near your entire budget.</p>
<h2>Version 2</h2>
<p><img style="margin: 12px 0px 5px 10px; float: right; border: 8px solid #ffffff;" src="http://blogs.headspring.com/content/binary/garbage.jpg" alt="a phenomena which Fred Brooks discusses in his book The Mythical Man Month, the Version Two Problem" /></p>
<p>Another thing to mention in growing systems is, one of the most common phenomena which<br />
Fred Brooks discusses in his book The Mythical Man Month, namely, the Version Two<br />
Problem with software development. Ironically, what happens very, very often is that<br />
the first application offer grows. The version one of the product helps enable the<br />
business and grows because the business starts with absolutely nothing. And as soon<br />
as you get something of value you have people start using it. The users then request<br />
additional features, which you add and give to them, and the system grows into something<br />
very valuable. However, as discussed, without the proper construction techniques,<br />
that system will become a legacy system, in other words, a system that can no longer<br />
be modified. It will most likely be used for a fairly significant period of time,<br />
maybe even years, upon which problems will develop, inconsistencies between the way<br />
the software operates and the way the business operates. When a pent up demand for<br />
new features is eventually met by a system rewrite, often what will manifest is a<br />
goal to make the new system perfect, capable of solving every problem the business<br />
has, plus every problem the business may ever have. Typically when the new system<br />
is built, it is built with no concerted effort to slowly bring it up alongside the<br />
existing legacy system. Instead, there is an attempt to do a wholesale replacement,<br />
and to make the new system far different than the legacy system, which leads to a<br />
couple of potential risks:</p>
<ol>
<li>There is the risk of never feeling comfortable releasing the software because it's<br />
never going to be perfect.</li>
<li>There is another risk that's not discovered often until late in the process, the risk<br />
of not being able to migrate the data captured in your existing system, into the new<br />
system, because they're really so different from one another.</li>
</ol>
<h2>Growing a Replacement</h2>
<p><img style="margin: 10px 0px 0px 10px; float: right;" src="http://blogs.headspring.com/content/binary/newgrowth.jpg" alt="a new system" border="0" /></p>
<p>At Headspring, we actually prefer to solve the Version Two Problem by first slowly<br />
bringing up a new system based on your old system, replacing your existing system<br />
feature by feature, and getting production users onto the new system as quickly as<br />
possible.</p>
<p>Of course, once you can fully turn off the old system you are free to innovate as<br />
much as you'd like on the new platform.</p>
<p>With the construction techniques we use, particularly the automated testing that we<br />
do on software, we prevent the problem that companies run into in legacy systems which<br />
is that they can no longer change them at some point.</p>
<p>And we prefer to threat load the data conversion as well so that we learn quite a<br />
bit about the shape of the current system by the data. For instance, there may be<br />
a column in one of the tables that is null in 100% of the records. And so that tells<br />
us very definitively... Guess what? This column isn't used. So, guess what, the field<br />
that represents that column in the UI is also not used, therefore, that feature is<br />
not used and that helps us understand the importance of the feature. This is an example<br />
of analysis that contributes to the direction of the version, helps us prioritize<br />
effectively, and comes from front-loading the data conversion.</p>
<p>There are many other ideas one can use to reduce risks in legacy system replacement<br />
projects. Really there are just more lessons learned than one can count. One of the<br />
lessons learned for even us as a company is that there are ways of approaching projects<br />
that are dramatically less risky than other approaches, and that choosing the right<br />
approach makes all the difference in seeing the investment you put into it result<br />
in real value.</p>
<h2>ROI???</h2>
<p>One of the things unfortunate about software projects is how they differ from other<br />
investments. When you put money into other sorts of investments, for example an automobile,<br />
you expect a certain minimal level of return on your investment. Even if you buy the<br />
cheapest automobile on the market, you expect that vehicle to be able to run for several<br />
years and take you at least 50,000 miles. However, in software projects it's very<br />
common for one to invest a very large sum of money and get no return on an investment,<br />
meaning the software never gets to production. (The users never actually begin using<br />
that system.) Software development makes the stakes higher for really managing your<br />
risks and choosing the right vendor to build a product.</p>
<p><img src="http://blogs.headspring.com/aggbug.ashx?id=2ec3b590-f7d4-4fea-9281-2fb8a80739ce" alt="" width="0" height="0" /></p>
