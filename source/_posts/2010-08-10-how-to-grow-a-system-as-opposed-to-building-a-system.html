---
layout: post
title: How to grow a system as opposed to building a system
tags: []
status: pending
type: post
published: false
meta:
  _edit_last: '4'
---
<em><span style="text-decoration: underline;">
</span></em> <img style="margin: 2px 0px 0px 10px; float: right;" src="http://blogs.headspring.com/content/binary/grow.jpg" alt="grow a system as opposed to building a system" border="0" /> With
regards to growing a system instead of building it, there are lots of lessons that
have been learned throughout the decades in software development, and we at Headspring
prefer not to make the mistakes of previous generations of software development teams
and software development vendors. This means learning from those mistakes and researching,
what in computer science terms are, the ancient scriptures of software which are now
three decades old. That is pretty ancient in software development terms.

Growing a system is what is natural. That is organic software development, to grow
a system over time and consistently test it, consistently use it, and consistently
refine it.

<img style="margin: 2px 10px 0px 0px; float: left;" src="http://blogs.headspring.com/content/binary/growing.gif" alt="slowly morph it" border="0" />

It is much like making a clay pot where one starts with a piece of clay. As you start
spinning the wheel, you slowly morph it. You slowly ease it into the shape of a pot
as opposed to building a mold and then injecting clay into the mold or molten aluminum
or something like that.

In the absence of grown development, you don't get feedback until late in the game
when you try to implement. As good as your testing is, until you put the actual users
and the actual data in the actual environment, you don't have proof that the system
solves a business problem. You only have a "good idea" prior to implementation, and,
as some people's good ideas are better than others, you don't have any evidence that
the system actually solves the problem it should.<!--more-->

And so, the sooner you could put your idea into production, the sooner you could have
real feedback feature by feature. Many are skeptical about how soon something can
actually be put into production. You can go in production with just two small features
and only one type of user.

Users can begin using the system with one initial role. Perhaps you will ultimately
have 26 different user groups, different types of security roles, or different types
of people that are going to use the system. But, if you can get the system up and
running for just one of those groups of users you've delivered some value and proved
out that their day to day jobs can be affected and improved by the computer system.
Then you may grow the system user group by user group instead of waiting a significant
period of time before actually implanting the software in a production environment.
This of course will help you evaluate the capability of the vendor you hire before
you spend anywhere near your entire budget.
<h2>Version 2</h2>
<img style="margin: 12px 0px 5px 10px; float: right; border: 8px solid #ffffff;" src="http://blogs.headspring.com/content/binary/garbage.jpg" alt="a phenomena which Fred Brooks discusses in his book The Mythical Man Month, the Version Two Problem" />

Another thing to mention in growing systems is, one of the most common phenomena which
Fred Brooks discusses in his book The Mythical Man Month, namely, the Version Two
Problem with software development. Ironically, what happens very, very often is that
the first application offer grows. The version one of the product helps enable the
business and grows because the business starts with absolutely nothing. And as soon
as you get something of value you have people start using it. The users then request
additional features, which you add and give to them, and the system grows into something
very valuable. However, as discussed, without the proper construction techniques,
that system will become a legacy system, in other words, a system that can no longer
be modified. It will most likely be used for a fairly significant period of time,
maybe even years, upon which problems will develop, inconsistencies between the way
the software operates and the way the business operates. When a pent up demand for
new features is eventually met by a system rewrite, often what will manifest is a
goal to make the new system perfect, capable of solving every problem the business
has, plus every problem the business may ever have. Typically when the new system
is built, it is built with no concerted effort to slowly bring it up alongside the
existing legacy system. Instead, there is an attempt to do a wholesale replacement,
and to make the new system far different than the legacy system, which leads to a
couple of potential risks:
<ol>
	<li>There is the risk of never feeling comfortable releasing the software because it's
never going to be perfect.</li>
	<li>There is another risk that's not discovered often until late in the process, the risk
of not being able to migrate the data captured in your existing system, into the new
system, because they're really so different from one another.</li>
</ol>
<h2>Growing a Replacement</h2>
<img style="margin: 10px 0px 0px 10px; float: right;" src="http://blogs.headspring.com/content/binary/newgrowth.jpg" alt="a new system" border="0" />

At Headspring, we actually prefer to solve the Version Two Problem by first slowly
bringing up a new system based on your old system, replacing your existing system
feature by feature, and getting production users onto the new system as quickly as
possible.

Of course, once you can fully turn off the old system you are free to innovate as
much as you'd like on the new platform.

With the construction techniques we use, particularly the automated testing that we
do on software, we prevent the problem that companies run into in legacy systems which
is that they can no longer change them at some point.

And we prefer to threat load the data conversion as well so that we learn quite a
bit about the shape of the current system by the data. For instance, there may be
a column in one of the tables that is null in 100% of the records. And so that tells
us very definitively... Guess what? This column isn't used. So, guess what, the field
that represents that column in the UI is also not used, therefore, that feature is
not used and that helps us understand the importance of the feature. This is an example
of analysis that contributes to the direction of the version, helps us prioritize
effectively, and comes from front-loading the data conversion.

There are many other ideas one can use to reduce risks in legacy system replacement
projects. Really there are just more lessons learned than one can count. One of the
lessons learned for even us as a company is that there are ways of approaching projects
that are dramatically less risky than other approaches, and that choosing the right
approach makes all the difference in seeing the investment you put into it result
in real value.
<h2>ROI???</h2>
One of the things unfortunate about software projects is how they differ from other
investments. When you put money into other sorts of investments, for example an automobile,
you expect a certain minimal level of return on your investment. Even if you buy the
cheapest automobile on the market, you expect that vehicle to be able to run for several
years and take you at least 50,000 miles. However, in software projects it's very
common for one to invest a very large sum of money and get no return on an investment,
meaning the software never gets to production. (The users never actually begin using
that system.) Software development makes the stakes higher for really managing your
risks and choosing the right vendor to build a product.

<img src="http://blogs.headspring.com/aggbug.ashx?id=2ec3b590-f7d4-4fea-9281-2fb8a80739ce" alt="" width="0" height="0" />
