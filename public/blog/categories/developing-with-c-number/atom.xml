<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: developing with C# | Headspring Labs]]></title>
  <link href="http://headspringlabs.com/blog/categories/developing-with-c-number/atom.xml" rel="self"/>
  <link href="http://headspringlabs.com/"/>
  <updated>2013-07-22T23:36:54-05:00</updated>
  <id>http://headspringlabs.com/</id>
  <author>
    <name><![CDATA[Headspring Labs]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Becoming a Headspringer: Take Advantage of Working with Smart People]]></title>
    <link href="http://headspringlabs.com/blog/becoming-a-headspringer-take-advantage-of-working-with-smart-people/"/>
    <updated>2012-04-10T00:00:00-05:00</updated>
    <id>http://headspringlabs.com/blog/becoming-a-headspringer-take-advantage-of-working-with-smart-people</id>
    <content type="html"><![CDATA[<p>As I was pondering a new topic to blog, I stumbled into one this morning. I was running some ideas by a few Headspringers, and they provided several options. I decided to go with a hybrid of their suggestions. What I originally planned to blog was a way to test Enumeration subclasses of the <a href="https://bitbucket.org/headspringlabs/tarantino/wiki/Home" target="_blank">Enumeration class from Tarantino</a>. What I ended up with was an even better way to test them. This is not an unusual happenstance at Headspring. If you talk to other Headspringers, you’re going to learn something new. It never ceases to amaze me how often I’m learning something. I like to think I’m doing some teaching, too, but I’m confident that I’m currently learning more than teaching.</p>


<p>In case it isn’t clear by the title, part of becoming a Headspringer is to learn from the great people you get to work with every day. So, if you'd like the opportunity to work with talented, passionate people, <a href="http://www.headspring.com/about-us/careers">we are hiring!</a></p>


<p>Now let’s get to the original idea of testing the Enumeration subclasses. I will walk through my original code, then what <a href="http://www.headspring.com/2012/02/get-to-know-a-developer-brandon-barry">Mr. Brandon Barry</a> showed me, and why it’s an improvement.</p>


<p>Originally, I had a test that gets all the subclasses of Enumeration, loops through them, and verifies all the values are unique. The test looked like this:<br />
[gist id=2348233 file=All_Enumerations_should_contain_unique_ids_test.cs]<br />
After talking to a few Headspringers, Brandon mentioned TestCaseSource, which turned out to be pretty perfect for this situation. Using TestCaseSource is similar to TestCase, which <a href="http://www.headspring.com/2012/03/why-i-like-testcase">Chris Missal blogged</a> about a couple weeks ago. You could use TestCase for this if you only wanted to test a few specific enumerations. Since I want to test all subclasses of Enumeration all the time, TestCaseSource was a much better fit. Now I don't have to worry about forgetting to add an Enumeration to the test.</p>


<p>Now the test looks like this:<br />
[gist id=2348235 file=Enumeration_should_contain_unique_ids_test.cs]<br />
Basically, NUnit runs a test per type in EnumerationTypes and passes that type into the now-parameterized test. The primary benefit of this method is that it tests one Enumeration at a time. It also makes the test simpler by removing the muck and letting you focus on the actual test. As an added bonus, it integrates with <a href="http://www.jetbrains.com/resharper/">Resharper</a>’s test runner, which means you can debug an individual test without having to loop through the set to get to the one you want.</p>


<p>I created three test subclasses, and TestEnum3 has duplicate values of 1. Here’s what the runner looks like:</p>


<p><a href="http://www.headspring.com/wp-content/uploads/2012/04/CropperCapture4.jpg"><img style="padding-left: 0px; padding-right: 0px; padding-top: 0px; border-width: 0px;" src="http://www.headspring.com/wp-content/uploads/2012/04/CropperCapture4_thumb.jpg" alt="CropperCapture[4]" width="560" border="0" /></a><br />
<span style="font-size: x-small; color: #666;">Click image to enlarge</span></p>


<p>You can see in the image above that my original test just fails with "TestEnum3 contains duplicate ID of 1". When using the TestCaseSource you get the test breakdown of each Enumeration, can clearly see that TestEnum3 is the one that fails, and can re-run that one individually. It also shows you what exactly is being tested, so you can verify you're testing everything you think you're testing.</p>


<p>And now it’s fixed:</p>


<p><a href="http://www.headspring.com/wp-content/uploads/2012/04/CropperCapture6.jpg"><img style="padding-left: 0px; padding-right: 0px; padding-top: 0px; border-width: 0px;" src="http://www.headspring.com/wp-content/uploads/2012/04/CropperCapture6_thumb.jpg" alt="CropperCapture[6]" width="560" border="0" /></a><br />
<span style="font-size: x-small; color: #666;">Click image to enlarge</span></p>


<p>If you would like to see more details on the Enumeration class, you can <a href="http://lostechies.com/jimmybogard/2008/08/12/enumeration-classes/">read Jimmy Bogard’s post on the subject</a>. If you would like more details about this particular test, feel free to leave a comment.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finding Closure]]></title>
    <link href="http://headspringlabs.com/blog/finding-closure/"/>
    <updated>2012-03-09T00:00:00-06:00</updated>
    <id>http://headspringlabs.com/blog/finding-closure</id>
    <content type="html"><![CDATA[<p>When writing software, we constantly create abstractions.  The goal each time is to present a simple interface in front of something more complex, hiding the gory details from us so we can focus on other things.  The problem is, <a href="http://en.wikipedia.org/wiki/Leaky_abstraction">abstractions leak</a>.  Even when you go to great effort to create a really exellent abstraction, some unfortunate implementation detail manages to rear its ugly head.  This even happens with things so fundamental that we take them for granted.  Take the 'foreach' keyword in C#:</p>


<p><div><script src='https://gist.github.com/1990055.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>


<p>Where we would expect the output to be:<br />
    Hello, Larry!<br />
    Hello, Moe!<br />
    Hello, Curly!</p>


<p>Instead, we see:<br />
    Hello, Curly!<br />
    Hello, Curly!<br />
    Hello, Curly!</p>


<p>Fortunately, ReSharper points out that something fishy is going on with the reference to <code>name</code> that appears in the loop body: <strong>"Access to modified closure."</strong>  If you follow the ReSharper suggested fix, you get this:</p>


<p><div><script src='https://gist.github.com/1990084.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>


<p>Oddly, introducing this local variable <em>does</em> fix the output, but why?  To find out, let's first rewrite the original version using a transformation from a <code>foreach</code> loop to a <code>while</code> loop, since that's the first thing the compiler does for us.  It still erroneously prints "Hello, Curly!" three times:</p>


<p><div><script src='https://gist.github.com/1990116.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>


<p>ReSharper still highlights the use of <code>name</code> within the loop body, and still says it is an "Access to modified closure."  Before we can try to fix the problem, we're going to have to make sense of that warning.</p>


<h2>What's a Closure?</h2>


<p>The word "closure" comes up a lot when talking about any language that has anonymous inline functions.  In C#, that means anonymous delegates and their shorthand lambda expressions introduced with <code>=&gt;</code>.  You have comparable anonymous functions in Javascript, Ruby, Python, etc.  Whenever you have an anonymous function whose body refers to identifiers in the surrounding scope, the function earns the right to call itself a closure.</p>


<p>Lambdas are really shorthand for a class with one method as well as the instantiation of that class.  In our example above, the lambdas are living beyond the execution of the loop, and that means they need to live beyond the normal scope of the loop variable, <code>name</code>.  In order to work, they'll need to hold onto something about that variable.  In fact, they hold onto the <em>environment</em> that was in effect at the moment the lambda was reached.  By environment, I mean <em>all</em> of the local variables they might be referring to.  It is as if we wrote the following, which also prints "Hello, Curly!" three times:</p>


<p><div><script src='https://gist.github.com/1990154.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>


<p>AHA! See how we have only <em>one</em> instance of Environment shared by all the <code>Greeter</code>s, and each iteration of the loop messes with the <code>name</code> field <em>inside</em> that shared Environment?  No wonder our final loop prints out the same thing each time: all the items in <code>delayedGreetings</code> refer to the same Environment, which contains only one name, which equals whatever we set it to <em>last</em>.</p>


<p>They call these lambdas "closures" because the secret object behind the scenes is grasping-at / enveloping / <em>closing-on</em> the local environment.  As we see in the last example, even after the environment is closed on, we can still affect that environment.  We say that the lambda is closing on the <em>variables themselves</em> rather than simply holding a reference to their <em>values</em>.</p>


<p><strong>Even foreach leaks.</strong></p>


<h2>Fixing foreach</h2>


<p>So we've got this fancy compiler that can take a combination of <code>foreach</code> and lambda expressions, rewriting them into some equivalent-yet-verbose code, which in turn is easier to compile.  It's a big abstraction that usually works so well we don't stop to think it's even <em>happening</em>.  How could we fix it?</p>


<p>It seems the whole problem comes down to the fact that with one shared environment, each iteration messes with a shared mutable object.  We get one environment per scope, though, and the <code>while</code> loop body introduces a new, more-local scope of its own!  We could take advantage of that by declaring the loop-iteration variable <code>name</code> <em>within</em> the <code>while</code> instead of <em>before</em> it.  This way, each iteration will get its own Environment with its own <code>name</code>.  Nothing shared, nothing mutated, leaving us with the three distinct greetings we wanted.  In other words, we wish that <code>foreach</code> gets translated into a <code>while</code> loop like so:</p>


<p><div><script src='https://gist.github.com/1990196.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>


<p>ReSharper's suggestions basically accomplish the same thing.  By introducing a seemingly-redundant copy within the smaller scope, the environment used by the lambdas is different in each iteration.</p>


<p>Usually when something as fundamental as a looping keyword has a problem like this, the language designers don't really have the option of correcting it.  It's technically a breaking change to make all <code>foreach</code> loops translate to the better version of the <code>while</code> seen in the last example.  <strong>However, they are going to be <a href="http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx">fixing foreach in C#5</a>.</strong> It's a breaking change, but one that will <em>fix</em> more mistakes than it <em>creates</em>!</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Reasons to Use Abstract Classes in C#]]></title>
    <link href="http://headspringlabs.com/blog/two-reasons-to-use-abstract-classes-in-c/"/>
    <updated>2011-07-29T00:00:00-05:00</updated>
    <id>http://headspringlabs.com/blog/two-reasons-to-use-abstract-classes-in-c</id>
    <content type="html"><![CDATA[<p>Do you find yourself writing the same methods over and over in different classes? Say your project needs both a "Dog" class and a "Cat" class -- do you end up writing a "sleep" method for both? What if, in two months, the client needs you to add a "possum" to the system? Do you end up going in and retyping "sleep" instructions yet again? When you're modeling a system with many similar parts, it takes way too much time and effort to keep duplicating code for each class. Imagine how hard it would be to maintain a large project with thousands of classes! Besides, it violates the DRY principle of good programming: Don't Repeat Yourself! There must be a better way.</p>


<p>Thankfully, C# has built-in features for sharing code between classes. One of these is called an "abstract class". Just create a new class with the keyword "abstract" (e.g. "public abstract class Mammal") and write in its body all the methods you would like your other classes to share in common. Since an abstract class is still a class, your "Cat" and "Dog" classes can inherit from it using a colon (e.g. "public Cat : Mammal"). This means that instead of writing a "sleep" method for each animal, you only need to write it in the "Mammal" class, and the other animals will be able to use it too.<br />
But if any class can have inheritance, why not just use a regular class? The answer is that abstract classes have two special features:</p>


<p>1. They cannot be instantiated (made into objects),<br />
2. They can have special methods called "abstract methods".</p>


<p>"Wait a minute," you may be thinking, "Why would I want a class that can't become an object?!" Sounds useless, right? However, consider the purpose of an abstract class: it contains common methods (and fields) that multiple child classes inherit from, but it does not attempt to follow these directions itself. In fact, a parent class is often missing vital information about the methods and fields it contains, because each child may use them a little bit differently. The "Mammal" abstract class only has what is common to all mammals -- since some mammals can't crawl and other mammals can't gallop, the "Mammal" class can't do either one. Imagine what would happen if you tried to instantiate a "generic" mammal: you'd get a featureless mass of hair, muscle and bone that probably wouldn't survive on its own! In the same way, it is undesirable (sometimes dangerous!) to leave a class open to instantiation when it is simply a placeholder for common features. Guard against this possibility by using an abstract class.</p>


<p>What if two classes have methods so different that the only common factor is their name? This is where an abstract method comes in handy. An abstract method looks just like a normal method, except it has the word "abstract" (e.g. "abstract exampleMethod(args);" ) and a semicolon ";" instead of body brackets "{}". What does it do? It basically tells each inheriting class to create its own method with that same name. For instance, since a dog and a bat both sleep, you could write a "sleep" method in the "Mammal" class. However, there are very few commonalities between a dog's sleep and a bat's sleep. So instead of trying to account for each individual animal's sleeping habits, you would make the "sleep" method abstract. Now the code won't even compile until each animal that inherits from "Mammal" has a method called "sleep", using the "override" keyword to replace the abstract one (e.g. "public override sleep(args) {}" ). Now even though all mammals sleep, each individual mammal can sleep in its own way. After this, you may be wondering, "Why even bother putting that method in the parent class? Each inheritor is going to have its own version anyway." You really do want to have that abstract class, not to prevent syntax errors, but to prevent human memory errors. You may know intellectually that all mammals sleep, but without a mechanism forcing you to write a "sleep" method for each mammal, it is all too easy to forget to do so. You may not even realize your mistake until you get a phone call from the client in the middle of the night. By refusing to compile until each abstract method is implemented in every inheriting class, the C# compiler is doing you a favor: it's helping you remember the obvious.</p>


<p>Abstract classes help you improve your code not only through what they can do, but also through what they can't. They can hold common features for many classes to inherit, without accidentally becoming objects themselves. They can also force you to write unique implementations of a common method, preventing human errors of forgetfulness. When you set up a class hierarchy, seriously consider whether you need a normal class to inherit from, or whether an abstract class will do. It may end up making the difference between a solid or buggy program.</p>


<p>Now, if only we had something to write the rest of our code for us...</p>

]]></content>
  </entry>
  
</feed>
